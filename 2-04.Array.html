<!DOCTYPE html>
<html>
  <head>
    <title>Document</title>
  </head>
  <body>
    <div id="div1"></div>
    <script>
      //toString()
      var fruits = ["Banana", "Orange", "Apple"];
      console.log(fruits.toString());

      //join()
      console.log(fruits.join(" , "));
      var txt = "Banana<br>";
      txt += "Orange<br>";
      txt += "Apple";

      //push("") -> 값넣기
      var arr = [];
      arr.push("Banana");
      arr.push("Orange");
      arr.push("Apple");

      //   document.getElementById("div1").innerHTML = txt;
      document.getElementById("div1").innerHTML = arr.join("<br>");

      //pop()
      //배열의 가장 마지막 element를 제거해준다
      //pop() 하면 , 제거된 element 리턴함

      var arr2 = fruits.pop(); // Apple제거
      console.log(arr2);
      console.log(fruits);

      //push()
      //배열의 가장 마지막에 element를 추가 한다.
      fruits.push("Kiwi"); // Kiwi추가
      console.log(fruits);

      //shift()
      //배열의 첫번째 element제거함
      //shift() 리턴으로 제거된 element 반환
      var str = fruits.shift();
      console.log(str);
      console.log(fruits);

      //unshift()
      //배열의 첫번째 새 element 추가
      fruits.unshift("Lemon");
      console.log(fruits);

      //바나나로 변환
      fruits[0] = "Banana";

      console.log(fruits);

      fruits[fruits.length - 1] = "Lemon"; // 마지막 위치에 레몬 넣기
      console.log(fruits);

      //Splice()
      //중간에 배열의 elemnet 를 삭제 추가 가능
      //첫번재 - 시작위치
      //두번째 - 삭제할 element 수

      var fruits = ["Banana", "Orange", "Apple"];
      //   fruits.splice(1, 1, "Lemon", "Kiwi"); // Orange 삭제 , Lemon, kiwi추가
      fruits.splice(1, 0, "Lemon", "Kiwi"); // 삭제없이 ,Orange자리에  Lemon, kiwi추가 -> Orange배열 인덱스 뒤로 밀림
      console.log(fruits);

      //concat()
      //배열 합치는 내장함수

      var myBoys = ["hong"];
      var myGirls = ["joy", "joey"];

      var myChildren = myBoys.concat(myGirls);

      console.log(myChildren);

      //slice()
      //원하는 엘리먼트만 추출 하는 내장함수
      //   var fruits2 = fruits.slice(1, 3); // Lemon , Kiwi
      //   var fruits2 = fruits.slice(1); // Lemon 부터 뒤에 전부
      //   console.log(fruits2);

      //sort()
      //순서에 맞게 정렬
      console.log(fruits.sort());

      var points = [40, 100, 70, 21, 99]; //순서를 문자열 로 인식
      //   console.log(points.sort());

      // 숫자 벨류의 크기 순서대로 sorting =>오름차순
      points.sort((a, b) => {
        // if (a > b) {
        //   return 1;
        // } else if (a < b) {
        //   return -1;
        // } else {
        //   return 0;
        // }
        //위의 코드와 같다.
        return a - b; // 오름차순
      });

      //reverse 내장함수
      // 순서 반대로

      console.log(points);

      points.reverse();

      console.log(points);

      //   배열의 오브젝트
      var persons = [
        {
          name: "조이조이",
          point: 78,
          city: "서울",
        },
        {
          name: "가가멜",
          point: 85,
          city: "서울",
        },
        {
          name: "스머프",
          point: 99,
          city: "서울",
        },
        {
          name: "유비",
          point: 22,
          city: "제주",
        },
      ];

      persons.sort((a, b) => {
        // if (a.point > b.point) {
        //   return 1;
        // } else if (a.point < b.point) {
        //   return -1;
        // } else {
        //   return 0;
        // }
        // 위의 조건문 의 simple 코드
        // return a.point > b.point ? 1 : a.point < b.point ? -1 : 0; // 오름차순
        return a.point < b.point ? -1 : a.point > b.point ? 1 : 0; // 내림차순
      });
      console.log(persons);

      //filter()
      //배열에서 조건에 맞는 정보만 추출

      //  80점 이상인 사람만 추출
      var pass = persons.filter((person) => {
        return person.point > 80;
      });

      console.log(pass);

      //객체배열에서 제주인 사람만 추출
      var jeju = persons.filter((person) => {
        return person.city == "제주";
      });
      console.log(jeju);

      //필터를 사용하지 않을시  for문과 if문을 사용하여 하나하나 치환 해야함
      // filter의 방식과 똑같다.
      var jeju = [];
      for (var i = 0; i < persons.length; i++) {
        if (persons[i].city == "제주") {
          jeju.push(persons[i]);
        }
      }
      console.log(jeju);

      //   var total = 0;
      var arr1 = [1, 2, 3, 4, 5];
      //   for (var x of arr1) {
      //     total += x;
      //   }
      //   console.log(total);

      //reduce
      //accumulator - 누산기
      //currentValue  - 배열을 읽으면서 현재값
      //위의 코드와 같다.
      var total = arr1.reduce((a, c) => {
        return a + c;
      });
      console.log(total);

      //map
      //Map() 메소드는 배열의 각각의 요소에 대하여 순차적으로 주어진 함수를 실행한 반환 값을 모아 새로운 배열을 반환합니다.
      var userList = [
        {
          firstname: "홍",
          lastname: "백",
          email: "sh@duam.net",
        },
        {
          firstname: "수",
          lastname: "지",
          email: "nope@duam.net",
        },
        {
          firstname: "윈",
          lastname: "터",
          email: "winter@duam.net",
        },
        {
          firstname: "백",
          lastname: "구",
          email: "white@duam.net",
        },
      ];

      //필요한 정보만 맵으로 모아서 반환값으로 리턴
      var userList2 = userList.map((user) => {
        return {
          fullname: user.lastname + " " + user.firstname,
          firstname: user.firstname,
          lastname: user.lastname,
        };
      });

      console.log(userList2);
    </script>
  </body>
</html>
